# JVM内容

### 第一章、自动内存管理机制

### 第二章、垃圾回收与内存分配策略

### 第三章、虚拟机性能监控与故障处理工具

### 第四章、调优案列分析与实战

### 第五章、类文件结构

### 第六章、虚拟机类加载机制

### 第七章、虚拟机字节码执行引擎

### 第八章、类加载及执行子系统的案列与实战

### 第九章、编译期优化

### 第十章、运行期优化

### 第十一章、Java内存模式与线程

#### 目标：

了解java虚拟机内存模式的结构及操作，然后了解原子性、可见性、有序性在java内存模式的体现，最后先行发生原则的规则及使用，了解线程在java语言中的实现。

大量时间花费在磁盘IO、网络通信、数据库访问

#### （一）Java内存模式-JMM

内存模式的目标是定义程序中各个变量的访问规则。即在虚拟机中将变量存储到内存和从内存中去除变量的底层细节，此变量包括实例字段，静态字段，构成数组对象的元素；不包括局部变量和参数方法；后者是线程私有，不会被共享，自然不存在竞争。

##### 11.3、主内存与工作内存

Java内存模式规定所有的变量存储在主内存中，每条线程还有自己的工作内存（高速缓存），线程对变量的所有操作，都在工作内存进行，不能直接读写主内存的变量，不同线程之间无法直接访问对方工作内存中的变量，线程间的变量值传递均需通过主内存来完成，线程、主内存、工作内存三者关系如下:

![image-20210713112823954](C:\Users\CS_Chan\AppData\Roaming\Typora\typora-user-images\image-20210713112823954.png)

##### 11.4、内存间交互操作

关于主内存与工作内存之间的交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步回主内存之类实现细节；java内存模式定义以下8中操作来完成，必须保证每一种操作都是原子性、不可再分。

（1）Lock（锁定）：作用于主内存的变量，他把一个变量标识为一条线程独占的状态。

（2）unlock（解锁）：作用于主内存的变量，他把一个处于锁状态的变量释放出来，释放后的变量才能被其他线程线程锁定。

（3）read（读取）：作用于主内存的变量，他把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。

（4）load（载入）：作用于工作内存的变量，他把read操作从主内存中得到的变量值放入工作内存的变量副本中。

（5）use（使用）：作用于工作内存的变量，他把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时执行这个操作。

（6）assign（赋值）：作用于工作内存的变量，他把一个执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。

（7）store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。

把一个变量从主内存复制到工作内存，那就要顺序地执行read和load操作

把一个变量从工作内存同步回主内存，就要顺序地执行store和write操作

注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行

Java内存模型还规定了在执行上述8种
基本操作时必须满足如下规则：
（1）不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取；但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。

（2）不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。

（3）不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。

（4）一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。

（5）一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。

（6）如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。

（7）如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。

（8）对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。

##### 11.5、对于volatile型变量的特殊规则

##### 11.6、对于long和double变量的特殊规则

##### 11.7、原子性、可见性与有序性

Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的；

**原子性**：如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。

**可见性**：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改

普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。

同时synchronized和final也可以实现可见性，同步块的可见性

**有序性**：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的；前半句是指“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。

Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入。

synchronized的“万能”也间接造就了它被程序员滥用的局面，越“万能”的并发控制，通常会伴随着越大的性能影响，这点我们将在第12章讲解虚拟机锁优化时再介绍。

##### 11.8、先行发生原则

如果Java内存模型中所有的有序性都仅仅靠volatile和synchronized来完成，那么有一些操作将会变得很烦琐，但是我们在编写Java并发代码的时候并没有感觉到这一点，这是因为Java语言中有一个“先行发生”（happens-before）的原则。这个原则非常重要，它是判断数据
是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。

（1）程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。

（2）管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。

（3）volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。

（4）线程启动规则（Thread Start Rule）：Thread对象的start（）方法先行发生于此线程的每一个动作。

（5）线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。

（6）线程中断规则（Thread Interruption Rule）：对线程interrupt（）方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted（）方法检测到是否有中断发生。

（7）对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize（）方法的开始。

（8）传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。

#### （二）Java与线程

##### 1.1、使用内核线程实现

内核线程直接由操作系统内核支持的线程，这种线程由内核完成线程切换。

##### 1.2、使用用户线程实现



##### 2、java线程的实现

线程优先级不太靠谱；原因是Java线程是通过映射到系统的原生线程上来实现的，所以线程调度最终取决于操作系统，虽然很多操作系统都提供线程优先级的概念，但是并不见的能与java线程的优先级一一对应。windows优先级只有7种。

##### 3、线程的状态

![image-20210713223850399](C:\Users\CS_Chan\AppData\Roaming\Typora\typora-user-images\image-20210713223850399.png)



第十二章、线程安全与锁优化

#### 12.1

