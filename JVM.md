# JVM内容

## 第一部分、自动内存管理机制

### 第二章、JAVA内存区域与内存溢出异常

#### 2.1 运行时数据区域

##### 2.1.1 程序计数器

是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需
要依赖这个计数器来完成。
由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

##### 2.1.2 Java虚拟机栈-----栈

内存私有，生命周期与线程线程。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame[1]）用于存储**局部变量**表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

##### 2.1.3 本地方法栈

本地方法栈则为虚拟机使用到的Native方法服务；C++ Native方法

##### 2.1.4 Java堆

Java内存中最大的一块，Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，目的存放实例（对象信息）

Java堆是垃圾收集器管理的主要区域，叫GC堆；

根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

##### 2.1.5 方法区

线程共享；

##### 2.1.6 常量池

方法区的一部分；Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

##### 2.1.7 直接内存

也就是计算机本机内存；并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。

本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是
会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。

#### 2.2 虚拟机对象探秘

##### 2.2.1 对象的创建

##### 2.2.2 对象的内存布局

##### 2.2.3 对象的访问定位

##### 2.2.4 outofMenoryError异常

**Java堆溢出**

**虚拟机栈和本地方法栈溢出**

**方法区和常量池溢出**

**直接内存溢出**

### 第三章、垃圾收集器与内存分配策略

#### 3.2 对象已死？

判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。作者面试过很多的应届生和一些有多年工作经验的开发人员，他们对于这个问题给予的都是这个答案。

但是有个问题就是：至少主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。

**重点**用可达性分析（Reachability Analysis）来判定对象是否存活的

这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的

在Java语言中，可作为GC Roots的对象包括下面几种：
虚拟机栈（栈帧中的本地变量表）中引用的对象。
方法区中类静态属性引用的对象。
方法区中常量引用的对象。
本地方法栈中JNI（即一般说的Native方法）引用的对象。

**再谈引用**

1、**强引用**

以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

2、**软引用**

 如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
  软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中

3、**弱引用**

如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 
  弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。

4、**虚引用**

"虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。
  虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解

  被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

  特别注意，在世纪程序设计中一般很少使用弱引用与虚引用，使用软用的情况较多，这是因为软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。

**生存还是死亡**

此对象是否有必要执行finalize（）方法

**回收方法区**

很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%～95%的空间，而永久代（方法区）的垃圾收集效率远低于此。主要回收两部分：废弃常量和无用的类

判断废弃常量：。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说，就是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。

判断无用的类：1）该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。2）加载该类的ClassLoader已经被回收。3）该类对应java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代（方法区）不会溢出。

#### 3.3 垃圾收集算法

**标记-清除算法**

标记-清楚算法：首先标记出所有需要回收的对象，再标记完成后统一回收所有标记的对象，他的标记（判断对象），他的不足：效率问题，标记和清除两个过程的效率都不高；空间问题，标记清除滞后会产生大量不连续的内存碎片，对象过大时，无法找到连续足够的内存，不得不提前触发另一次垃圾收集工作。

![image-20210715223502333](C:\Users\CS_Chan\AppData\Roaming\Typora\typora-user-images\image-20210715223502333.png)

**复制算法**

为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

![image-20210715223449996](C:\Users\CS_Chan\AppData\Roaming\Typora\typora-user-images\image-20210715223449996.png)

**标记-整理算法**

提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的示意图如图所示。

![image-20210715223437656](C:\Users\CS_Chan\AppData\Roaming\Typora\typora-user-images\image-20210715223437656.png)

**分代收集算法**

当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为**新生代**和**老年代**，这样就可以根据各个年代的特点采用最适当的收集算法。

在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。

而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。

### 第四章、调优案列分析与实战



### 第五章、类文件结构

字节码

##### 5.1 class类文件的结构

任何一个class文件都对应唯一一个类或接口的定义信息。

Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表，后面的解析都要以这两种数据类型为基础，所以这里要先介绍这两个概念。

**无符号数属于基本的数据类型**，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。

**表**是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表，它由表6-1所示的数据项构成。

**常量池**

常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括了下面三类常量：类和接口的全限定名（Fully Qualified Name），字段的名称和描述符（Descriptor），方法的名称和描述符

##### 5.2 字节码指令简介

对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素。

### 第六章、虚拟机类加载机制

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

##### 6.1 类的加载时机

![image-20210716000911890](C:\Users\CS_Chan\AppData\Roaming\Typora\typora-user-images\image-20210716000911890.png)

**加载**，Java虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”（加载、验证、准备自然需要在此之前开始）

##### 6.2 类的加载过程

加载、验证、准备、解析和初始化这5个阶段所执行的具体动作

**加载：**

1）通过一个类的全限定名来获取定义此类的二进制字节流

2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

**验证：**

验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

**准备：**

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：

```java
public static int value = 123;
```

那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器＜clinit＞（）方法之中，所以把value赋值为123的动作将在初始化阶段才会执行

```java
public static final int value=  123;
```

编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。

**解析：**

**初始化：**

##### 6.3 类的加载器





### 第七章、虚拟机字节码执行引擎

##### 7.1 运行时栈帧结构

![image-20210716003225211](C:\Users\CS_Chan\AppData\Roaming\Typora\typora-user-images\image-20210716003225211.png)



### 第八章、类加载及执行子系统的案列与实战

### 第九章、编译期优化



### 第十章、运行期优化



### 第十一章、Java内存模式与线程

#### 目标：

了解java虚拟机内存模式的结构及操作，然后了解原子性、可见性、有序性在java内存模式的体现，最后先行发生原则的规则及使用，了解线程在java语言中的实现。

大量时间花费在磁盘IO、网络通信、数据库访问

#### （一）Java内存模式-JMM

内存模式的目标是定义程序中各个变量的访问规则。即在虚拟机中将变量存储到内存和从内存中去除变量的底层细节，此变量包括实例字段，静态字段，构成数组对象的元素；不包括局部变量和参数方法；后者是线程私有，不会被共享，自然不存在竞争。

##### 11.3、主内存与工作内存

Java内存模式规定所有的变量存储在主内存中，每条线程还有自己的工作内存（高速缓存），线程对变量的所有操作，都在工作内存进行，不能直接读写主内存的变量，不同线程之间无法直接访问对方工作内存中的变量，线程间的变量值传递均需通过主内存来完成，线程、主内存、工作内存三者关系如下:

![image-20210713112823954](C:\Users\CS_Chan\AppData\Roaming\Typora\typora-user-images\image-20210713112823954.png)

##### 11.4、内存间交互操作

关于主内存与工作内存之间的交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步回主内存之类实现细节；java内存模式定义以下8中操作来完成，必须保证每一种操作都是原子性、不可再分。

（1）Lock（锁定）：作用于主内存的变量，他把一个变量标识为一条线程独占的状态。

（2）unlock（解锁）：作用于主内存的变量，他把一个处于锁状态的变量释放出来，释放后的变量才能被其他线程线程锁定。

（3）read（读取）：作用于主内存的变量，他把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。

（4）load（载入）：作用于工作内存的变量，他把read操作从主内存中得到的变量值放入工作内存的变量副本中。

（5）use（使用）：作用于工作内存的变量，他把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时执行这个操作。

（6）assign（赋值）：作用于工作内存的变量，他把一个执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。

（7）store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。

把一个变量从主内存复制到工作内存，那就要顺序地执行read和load操作

把一个变量从工作内存同步回主内存，就要顺序地执行store和write操作

注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行

Java内存模型还规定了在执行上述8种
基本操作时必须满足如下规则：
（1）不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取；但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。

（2）不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。

（3）不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。

（4）一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。

（5）一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。

（6）如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。

（7）如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。

（8）对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。

##### 11.5、对于volatile型变量的特殊规则

关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制；

当一个变量定义为volatile之后，它将具备两种特性：

1）保证此变量对所有线程的可见性

2）

**Volatile**

Volatile变量具有synchronized的可见性特性，但是不具备原子特性。当一个变量定义为volatile之后，将具备：

​		1、保证此变量对所有的线程的可见性，当一个线程修改了这个变量的值，volatile保证了新值能立即同步到主内存，其他线程每次使用前当立即从主内存刷新。普通变量的值在线程间传递均需要通过主内存来完成。

​		2、禁止指令重排序优化，有volatile修饰的变量，赋值后多执行一个load add 操作，相等于内存屏障

**指令重排序**

​		1、有序性：即程序执行的顺序按照代码的先后顺序执行，

```java
int i = 0;              
boolean flag = false;
i = 1;                //语句1  
flag = true;          //语句2
```

从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证**语句1一定会在语句2前面执行吗？**不一定，为什么呢？**这里可能会发生指令重排序（Instruction Reorder）。**

一般来收，处理器为了提高运行效率，可能会对输入代码进行优化，他不保证程序每个语句的执行先后顺序同代码中的顺序一致，到那时他会保证程序最终执行结果和代码顺序执行的结果是一致的。

在计算机中，软件技术和硬件技术有一个共同的目标：**在不改变程序执行结果的前提下，尽可能的开发并行度。**编译器和处理器都遵从这一目标。
 这里所说的数据依赖性仅针对**单个处理器中执行的指令序列和单个线程中执行的操作**，在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果；但在**多线程程序中，**对存在控制依赖的操作重排序，可能会改变程序的执行结果。这是就需要**内存屏障来保证可见性了。**

**内存屏障**

作用：

**1.阻止屏障两侧的指令重排序；
2.强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。**

**java的内存屏障通常所谓的四种即LoadLoad,StoreStore,LoadStore,StoreLoad实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。**

**LoadLoad屏障：**对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
 **StoreStore屏障：**对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。
 **LoadStore屏障：**对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。
 **StoreLoad屏障：**对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能

`volatile`**的内存屏障策略非常严格保守，**非常悲观且毫无安全感的心态：

**在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；
在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；**

由于内存屏障的作用，避免了volatile变量和其它指令重排序、线程之间实现了通信，使得volatile表现出了锁的特性。

**volatile 性能：**

**volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。**



##### 11.6、对于long和double变量的特殊规则

##### 11.7、原子性、可见性与有序性

Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的；

**原子性**：如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。

**可见性**：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改

普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。

同时synchronized和final也可以实现可见性，同步块的可见性

**有序性**：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的；前半句是指“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。

Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入。

synchronized的“万能”也间接造就了它被程序员滥用的局面，越“万能”的并发控制，通常会伴随着越大的性能影响，这点我们将在第12章讲解虚拟机锁优化时再介绍。

##### 11.8、先行发生原则

如果Java内存模型中所有的有序性都仅仅靠volatile和synchronized来完成，那么有一些操作将会变得很烦琐，但是我们在编写Java并发代码的时候并没有感觉到这一点，这是因为Java语言中有一个“先行发生”（happens-before）的原则。这个原则非常重要，它是判断数据
是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。

（1）程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。

（2）管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。

（3）volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。

（4）线程启动规则（Thread Start Rule）：Thread对象的start（）方法先行发生于此线程的每一个动作。

（5）线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。

（6）线程中断规则（Thread Interruption Rule）：对线程interrupt（）方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted（）方法检测到是否有中断发生。

（7）对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize（）方法的开始。

（8）传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。

#### （二）Java与线程

##### 1.1、使用内核线程实现

内核线程直接由操作系统内核支持的线程，这种线程由内核完成线程切换。

##### 1.2、使用用户线程实现

而狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也可以支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。

##### 2、java线程的实现

线程优先级不太靠谱；原因是Java线程是通过映射到系统的原生线程上来实现的，所以线程调度最终取决于操作系统，虽然很多操作系统都提供线程优先级的概念，但是并不见的能与java线程的优先级一一对应。windows优先级只有7种。

##### 3、线程的状态

![image-20210713223850399](C:\Users\CS_Chan\AppData\Roaming\Typora\typora-user-images\image-20210713223850399.png)



### 第十二章、线程安全与锁优化

#### 概述：

介绍线程安全所涉及的概念和分类，同步实现的方式及虚拟机的底层运作原理，并且介绍了虚拟机为了实现高效并发锁采取的一系列锁优化措施

#### 12.1 线程安全

**线程本地存储（Thread Local Storage）**：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。

符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费
者”模式）都会将产品的消费过程尽量在一个线程中消费完，其中最重要的一个应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多**Web服务端应用都可以使用线程本地存储来解决线程安全问题。**



#### 12.2 锁优化

概述：介绍

高效并发是从JDK 1.5到JDK 1.6的一个重要改进，HotSpot虚拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，如适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）等，这些技术都是为了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。

##### 12.2.1 自旋转锁与自适应旋

##### 12.2.2 锁消除

##### 12.2.3 锁粗化

12.2.4 轻量级锁

12.2.5 偏向锁