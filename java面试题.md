### 1、String

1、String、StringBuilder、StringBuffer

String 类，属于java字符串对象，由java提供String类创建和操作字符串。

String的值不可变，这回导致每次对String的操作都会生成新的String对象，这样效率低下，而且大量浪费内存空间。当对字符串进行修改的时候，需要使用StringBuilder和StringBuffer类

StringBuilder和StringBuffer类的对象能够被多次的修改，

![image-20210818135658867](C:\Users\CS_Chan\AppData\Roaming\Typora\typora-user-images\image-20210818135658867.png)

StringBuilder 速度优势，线程不安全，多数情况建议使用SringBuilder

==与equals()的区别：

1. ==:比较引用类型比较的是地址值是否相同
2. equals:比较引用类型默认也是比较地址值是否相同，而String类重写了equals()方法，比较的是内容是否相同。

![image-20210818144857241](C:\Users\CS_Chan\AppData\Roaming\Typora\typora-user-images\image-20210818144857241.png)

### 2、并发编程

- java中守护线程（daemon）和本地线程（Use）区别

  - 任何线程都可以设置为守护线程和用户线程，通过方法 Thread.setDaemon(boolon)；true  则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()必须在  Thread.start()之前调用，否则运行时会抛出异常。

  - 区别

    - 唯一的区别是判断虚拟机(JVM)何时离开，Daemon 是为其他线程提供服务，如果全部的 User Thread  已经撤离，Daemon 没有可服务的线程，JVM 撤离。也可以理解为守护线程是 JVM  自动创建的线程（但不一定），用户线程是程序创建的线程；比如 JVM  的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是 Java  虚拟机上仅剩的线程时，Java 虚拟机会自动离开。

      扩展：Thread Dump 打印出来的线程信息，含有 daemon 字样的线程即为守护进程，可能会有：服务守护进程、编译守护进程、windows 下的监听 Ctrl+break的守护进程、Finalizer 守护进程、引用处理守护进程、GC 守护进程。

- 什么是多线程中的上下文切换？

  - 多个线程可以执行在单核或多核cpu上，单核CPU也支持多线程执行代码，CPU通过给每个线程分配CPU时间片(机会)来实现这个机制。。cpu为了执行多个线程，就需要不停的切换执行的线程，这样才能保证，所有的线程在一段时间内都有被执行的机会。此时，CPU分配给每个线程的执行时间段，称作它的时间片。CPU时间片一般为几十毫秒。cpu通过时间片分配算法来循环执行任务，当前任务执行一个时间片后切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。
  - 方法（调度算法）：**让步式上下文切换**和**抢占式上下文切换**。
    - 让步式上下文切换：执行线程主动释放CPU，与锁竞争严重程度成正比，可通过**减少锁竞争来避免**
    - 抢占式上下文切换：线程因分配的时间片用尽而被迫放弃CPU或者被其他优先级更高的线程所抢占，一般由于线程数大于CPU可用核心数引起，可通过**调整线程数，**适当减少线程数来避免
  - 引起线程上下文切换的原因
    - 当前正在执行的任务完成，系统的cpu正常调度下一个任
    - 当前正在执行的任务遇到i/o等阻塞操作，调度器挂起此任务，继续调度下一个任务。
    - 多个任务并发抢占资源，当前任务么有抢到锁资源，被调度器挂起，继续调度下一个任务
    - 用户的代码挂起当前任务，比如线程执行sleep方法，让出CPU。
    - 硬件中断

### 3、JVM

1)JVM内存模型

![image-20210820180607512](C:\Users\CS_Chan\AppData\Roaming\Typora\typora-user-images\image-20210820180607512.png)

java内存模型

![image-20210820181057391](C:\Users\CS_Chan\AppData\Roaming\Typora\typora-user-images\image-20210820181057391.png)

java内存模式规定所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能读写主内存。不用线程之间也无法直接访问对方工作中的变量，线程间变量的传递需要自己的工作内存和主内存之间进行数据同步进行

#### 指令重排序

在实际运行时，代码指令可能并不是严格按照代码语句顺序执行的。大多数现代微处理器都会采用将指令乱序执行（out-of-order execution，简称OoOE或OOE）的方法，在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待3。通过乱序执行的技术，处理器可以大大提高执行效率。而这就是指令重排。
